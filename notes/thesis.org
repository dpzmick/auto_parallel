* random experiments with clojure
** set game
- clojure code shorter than ocaml version
- blame 'apply' and things like that
- lazy data structures make things easier
** sorting
- be careful with lazy eval, threads don't start without a doall

* genetic algorithms
** parallelism methods
- master-slave
  - slaves compute fitness, master maintains population and does crossover/generational updating
- single individual per node, communicate w/ neighbors on topology
  - topology matters a lot
- multi-population with migration
- hierarchical, mutli-population on a single node w/ migration. multi-population
  between nodes w/ migration

* automatic parallelism
** I/O
I/O can't be autoconcurrent in an easy way bc all I/O blocks threads unless you
use I/O wrappers with callbacks, but if you are doing that, you are already
dealing with concurrency.

see: [[http://martintrojer.github.io/clojure/2013/07/07/coreasync-and-blocking-io/]]

[[http://blog.lahteenmaki.net/2013/01/haskell-and-non-blocking-asynchronous-io.html][haskell solution (good)]]

There's library called "Quasar" which adds fibers, but still doesn't use epoll
in the VM. Needs quasar wrappers for I/O libraries.

** computation
*** TODO add granularity control to each macro
For parlet, allow it to use any value defined before the parlet executes

#+BEGIN_SRC clojure
  (parlet

   {:granularity
    "bindings only evaulated in parallel if the granulatiry function returns true"
    (fn [y z] (and (> x 100) (> y 100)))}

   [a (foo y)
    b (foo z)]

   (+ a b))
#+END_SRC

Create similar granularity bindings for other macros.

*** TODO defparfun
** Every function call becomes a new task
** hard to delay a join

#+BEGIN_SRC clojure
    (defparfun naive [a] (naive (- a 1)))

    (defn naive-help [a] (naive (- a 1)))
    (defn naive [a] (join (new-task #(naive-help a))))
#+END_SRC
** we don't get tail recursion anyway, so who cares if we make it impossible

** discovery
use a profiler to find opportunities for these parallelism through these macros

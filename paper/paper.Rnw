\documentclass{article}
\usepackage{hyperref}

\usepackage{minted}
\usemintedstyle{emacs}

\bibliographystyle{plain}

\def\mintcode#1{\mbox{\mintinline{clojure}{#1}}}
\def\code#1{\mbox{\texttt{#1}}}
\def\parlet{\code{parlet}}

\author{
    Zmick, David\\
    \texttt{zmick2@illinois.edu}
}

\title{Macros for straightforward parallelism in Clojure}

\begin{document}
<<include=FALSE>>=
source("../vis/basic_plot.R")
data <- read.csv("../newopts.csv")
@

\maketitle

% question: Can macros be used to create interesting and useful parallelism
% tools for recursive functions in clojure.
\section{Introduction}

Clojure is a lisp--like language running on the Java Virtual Machine.
The language's default immutable data structures and sophisticated Software Transactional Memory (STM) system make it well suited for parallel programming.
Because Clojure runs on the Java Virtual Machine, Clojure developers can take advantage of existing cross--platform parallelism libraries, such as Java's excellent \code{ExecutorService} framework, to write parallel code.

% for example, writing a parallel map with atoms would be a big pain
However, taking advantage of Clojure's parallel potential is not entirely straightforward.
STM has proven to be very successful as a clear construct for concurrent programming\cite{Jones2007a}, but these constructs are often too low level to be of much use to developers whose central concerns are not parallelism\cite{Boehm2009}.

As a result, there are a variety of libraries designed to allow developers to take advantage of the parallelism potential in Clojure.\footnotemark{}\footnotemark{}\footnotemark{}\footnotemark{}\footnotemark{}
Many of these library functions and builtins are data-parallel; they are designed to apply some sort of operation to a set of data.
Developers have a good relationship with data parallel problems\cite{Okur2012a}, but Clojure's nature as a functional language with immutable structures also makes it possible to easily exploit control parallelism (also known as task parallelism\cite{Andradea, Rodr}).

\footnotetext[1]{\url{https://github.com/clojure/core.async}}
\footnotetext[2]{\url{https://github.com/TheClimateCorporation/claypoole}}
\footnotetext[3]{\url{https://clojuredocs.org/clojure.core/pmap}}
\footnotetext[4]{\url{http://clojure.org/reference/reducers}}
\footnotetext[5]{\url{https://github.com/aphyr/tesser}}

% even if it is expressed in control flow, it is still data parallelism probably
Using Clojure's macro system, we have implemented a set of macros which allow developers to take advantage of Clojure's parallelism potential when their existing code is written such that parallelism is exposed through control flow.
We have shown that it is possible to attain reasonable degrees of parallelism with minimal code changes (with respect to serial code).
These transformation can be applied to idiomatic Clojure code without the need for sophisticated dependency analysis often required in other parallelism systems.
% indicate that we cooperate with STM and other clojure constructs

% the other existing libraries are also a testament to this statement
% we sort of side stepped this by saying that the macros only work on pure code.
% Need to demonstrate that idiotmatic clojure code is actually pure and that these macros actually make sense.

\section{Macros}
\subsection{parlet}
The first of the parallel macros is called \parlet{}.
\parlet{} is a modified version of the Clojure let form.
The \parlet{} macro has exactly the same semantics as Clojure's \code{let}, but it evaluates all of it's bindings in parallel.
For example, suppose I had some long running function \code{foo}.
I need to add the result of two calls to this function.
In Figure \ref{fig:parlet_basic}, we use \parlet{} to make two calls to \code{foo}, then add the results.

\begin{figure}[h]
    \begin{minted}{clojure}
        (parlet
          [a (foo value1)
           b (foo value2)]
           ... ; some other code here
          (+ a b))
    \end{minted}
    \caption{Example of a parlet form}
    \label{fig:parlet_basic}
\end{figure}

In this example, the expressions \mintcode{(foo value1)} and \mintcode{(foo value2)} are both evaluated as \code{ForkJoinTask}s in a \code{ForkJoinPool}\cite{Lea2000}.

The calls to \code{foo} are both \code{forked} immediately, then we attempt to evaluate the body of the \code{let}.
This means that the code in the body of the \code{let} which does not depend on the computations of \code{a} and \code{b} can execute without delay.

This transformation is obviously only safe when \code{foo} does not have side effects which may impact the other code in the function, or the values of terms used in subsequent let terms.
In Clojure, it is very common (although not guaranteed by the compiler) for function calls to be pure.

Nested parlet macros will also behave quite well.

\begin{figure}[h]
    \begin{minted}{clojure}
        (parlet
          [a (foo 100)]
          ;; some other code not using a
          (parlet
            [b (foo 200)]
            (+ a b)))
    \end{minted}
    \caption{Nested parlet forms}
    \label{fig:parlet_noblock}
\end{figure}

In Figure \ref{fig:parlet_noblock}, calls to the function foo will be processed in the background until we reach the line using the variables that the results are bound to.
This means that parlets can be nested with little concern (again as long as functions are pure).

Code like this may not arise when the code is human generated, but it may arise when the code is generated by another macro.
We will see some examples of this later.

The parlet macro also supports dependency detection.
Clojure let forms can use names defined previously in the let, and the bindings are evaluated from first to last.

\begin{figure}[h]
    \begin{minted}{clojure}
        (parlet
        [a 1
         b (+ 1 a)]
         a)
    \end{minted}
    \caption{A parlet containing a dependency}
    \label{fig:parlet_dep}
\end{figure}

Without the parlet, the let form in Figure \ref{fig:parlet_dep} would evaluate to 2.
If we plan on evaluating each binding in parallel, we can't allow the bindings to have dependencies.
So, the parlet macro looks through the bindings in the macro to determine if any of them depend on
any of the names defined previously in the macro.
If there are any, the macro will halt the compiler and report an error to the user.

This simple dependency check, as well as the commonplace purity in Clojure code, allow us to ensure correct parallelism with this simple macro.
Because the Clojure compiler does not enforce purity, we still need to trust the programmer to validate the purity assumption before inserting the macro.
% but lots of clojure code is already pure blah blah blah

\subsection{parexpr}

Parexpr breaks down expressions and (aggressively) evaluates them in parallel.
parexpr uses parlet to parallelize forms.
Suppose again that I had a long running function foo, I wanted to call it twice, and add the results.
The code in Figure \ref{fig:parexpr} will make both of the long running calls to foo in parallel.

\begin{figure}[h]
    \begin{minted}{clojure}
        (parexp (+ (foo value1) (foo value2)))
    \end{minted}
    \caption{Example using parexpr to evaluate long running functions}
    \label{fig:parexpr}
\end{figure}

The macro crawls the expression and expands every subexpression into a parlet.
This macro has limited applicability, but, we can also convince ourselves of its correctness easily.

\subsection{defparfun}

The defparun macro is the most interesting of the 3 macros.
defparfun allows a programmer to parallelize calls to a recursive function.
This is best explained with an example:

% TODO check my own stupid syntax
\begin{minted}{clojure}
    (defparfun fib [n] (> n 30)
      (if (or (= n 1) (= n 2))
          1
          (+
            (fib (- n 1))
            (fib (- n 2)))))
\end{minted}

This defines a parallel Fibonacci function, which will only execute in parallel when the value of it's argument is greater than 30.

% TODO actual explain this
The macro first identifies any recursive call sites, then moves the function call as far ``up'' in the function as it can, without breaking any dependencies.
Again, this dependency check is relatively simple.
After this transformation, it is possible to replace the let forms which bind the function results to their values with parlet forms providing the same bindings.
The introduction of the parlet form introduces parallelism, so each recursive call will execute in the ForkJoin pool, in parallel.
Each of these subsequent recursive calls may create more tasks, which will also be executed in the pool.
ForkJoin pools are designed to handle this type of computation, so the computation will proceed without blocking (as long as function is pure and performs no thread--blocking I/O).
% TODO reference a ForkJoin pool paper

\section{Benchmarking}
\subsection{Setup}

\section{Results}
<<javafib, fig.pos="H", fig.cap="Fibonacci Java Performance", echo=F>>=
jfib <- plot_means_error_for_benchmark(data, "fib", "fj")
@

<<fibparfun, fig.pos="H", fig.cap="Fibonacci Clojure (defparfun) Performance", echo=F>>=
cljfib <- plot_means_error_for_benchmark(data, "fib", "parfun")
@

\section{Conclusions}
% the jvm is (mostly) awesome
% immutability makes things like this really straightforward

\bibliography{/home/dpzmick/Documents/Bibtex/senior-thesis.bib}

\end{document}

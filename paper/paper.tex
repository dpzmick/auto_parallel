\documentclass{article}
\usepackage{minted}
\usemintedstyle{emacs}

\begin{document}

% question: Can macros be used to create interesting and useful parallelism
% tools for recursive functions in clojure.
\section{Introduction}
% most important section in paper:
% - introduce the problem being solved
% - prove that this problem is interesting
% - why is this hard?
% - how does it differ from other approaches?
% - what are key results/limitations
Clojure is a lisp--like language running on the Java Virtual Machine with good support for concurrent and parallel programming.
Because Clojure is a lisp, it also has a powerful macro system.
Using Clojure's macro system, we have implemented a variety of macros which transform recursive serial code into equivalent parallel code, executing with the Java platform's ForkJoinPool executor service.

These macros are designed to allow developers to trivially utilize additional processing power, without doing much additional work.
The primary target audience is not developers concerned with extracting every last ounce of performance from their code, but instead developers trying to write highly expressive and readable code who would benefit from a speedup, but are not willing to rewrite substantial portions of their code, or write their code in a different manner to gain this speedup.
This means that these macros must be simple to use and must place very few of their decisions in the hands of the developers.
It also means that these macros must protect against invalid usage.

Unlike other approaches for simple parallelism in clojure, these macros parallelize control flow. % what's the opposite of data parallel
Many of the other Clojure parallelism constructs are data parallel, meaning that the parallelize operations on large sets of data. % example, pmap


The macros discussed in this paper only apply to a subset of the Clojure language. For example, code which manipulates state would be ill---suited for automatic parallelization with these macros.

This paper is divided into $n$ sections. The first discusses the macros we've implemented, along with the appropriate use cases for each. In the second section, we present benchmarks demonstrating the cases in which the parallelism macros can (and cannot) improve performance of existing code.

\section{Macros}
\subsection{parlet}
The first of the parallel macros is called parlet.
This macro is used to implement many of the others, so we will discuss it first.
Parlet is a modified version of Clojure let form.
Clojure's let form is used to bind names to values, then executes some other
Clojure forms in the new environment.
The parlet macro is exactly the same as a Clojure's let, but it evaluates all of
it's bindings in parallel (if there is no dependencies between them).
For example, suppose I had some long running function foo, if I needed to add
the result of two calls to this function, I could do the following:

\begin{minted}{clojure}
    (parlet
      [a (foo value1)
       b (foo value2)]
      (+ a b))
\end{minted}

This would execute the call to foo with value1 and the call to foo with value2
in parallel. The execution of each of these tasks is done in a ForkJoinPool.
Both tasks are submitted to the pool and told to execute in the background.
Then, in each form given to the let where the name is expected to have a value
bound to it, the name is replaced with a call to join for each new task. The
example above expands to:

\begin{minted}{clojure}
(let
 [a (fork (new-task (fn [] (foo v1))))
  b (fork (new-task (fn [] (foo v2))))]
 (+ (join a) (join b)))
\end{minted}

The joins are intentionally pushed into the forms in the let. Each join will
block until the computation finishes (if it has not already), so we push these
as far as we possibly can. This also means that nested parlets will benefit from
as much parallelism as possible. For example:

\begin{minted}{clojure}
    (parlet
      [a (foo 100)]
      ;; some other code not using a
      (parlet
        [b (foo 200)]
        (+ a b)))
\end{minted}

Expands to:

\begin{minted}{clojure}
(let
 [a (fork (new-task (fn [] (foo 100))))]
 ;; some other code not using a
 (let
  [b (fork (new-task (fn* ([] (foo 200)))))]
  (+ (join a) (join b))))
\end{minted}

Code like this may not arise when the code is human generated, but it may arise
when the code is generated by another macro. We will see some examples of this
later.

The parlet macro also supports dependency detection. Clojure let forms can use
names defined previously in the let, and the bindings are evaluated from first
to last. The following form is valid:

\begin{minted}{clojure}
    (let
     [a 1
      b (+ 1 a)]
     a)
\end{minted}

This form would evaluate to 2. If we plan on evaluating each binding in
parallel, we can't allow the bindings to have dependencies. So, the parlet macro
looks through the bindings in the macro to determine if any of them depend on
any of the names defined previously in the macro. If there are any, the macro
will halt the compiler and report an error to the user.

\subsection{parexpr}

Parexpr breaks down expressions and (aggressively) evaluates them in parallel.
parexpr uses parlet to parallelize forms. Suppose again that I had a long
running function foo, I wanted to call it twice, and add the results. With
parexpr the following will make both calls to foo in parallel:

\begin{minted}{clojure}
    (parexp (+ (foo value1) (foo value2)))
\end{minted}

The parlet macro expands to something like the following:

\begin{minted}{clojure}
(parlet
 [expr16512 (foo 11)
  expr16511 (foo 10)]
 (parlet
  [expr16513 (+ expr16511 expr16512)]
  expr16513))
\end{minted}

\end{document}
